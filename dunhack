#!/usr/bin/python3
#+
# Tool to commit hacks on dungeon and character files for udd <https://github.com/ldo/udd>.
# Invoke as
#
#     dunhack <cmd> ...
#
# to execute a command. Type
#
#     dunhack help
#
# for an overview of available commands.
#
# Copyright 2014-2015 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

from enum import \
    Enum
import sys
import os
import cairo
from colorsys import \
    hsv_to_rgb as hsv
import json
import fnmatch
import getopt
from dungeon import \
    DIR, \
    Character, \
    CharacterFile, \
    Dungeon, \
    DungeonFile
SPC = Dungeon.SPC
ROOM_SIDE = Dungeon.ROOM_SIDE
UC = Character.UC

#+
# JSON representation
#-

class IndentedOutput :
    "wrapper for an output text stream that prepends indentation onto every line." \
    " Can be used to wrap another instance of itself for nested indentation. Just" \
    " don’t switch streams in the middle of a line."

    indent = 4 * " "

    def __init__(self, parent) :
        self.parent = parent
        self.sol = True
    #end __init__

    def write(self, s) :
        while len(s) != 0 :
            if self.sol :
                self.parent.write(self.indent)
            #end if
            eol = s.find("\n")
            self.sol = eol >= 0
            if self.sol :
                eol += 1 # include newline
            else :
                eol = len(s)
            #end if
            self.parent.write(s[:eol])
            s = s[eol:]
        #end while
    #end write

    def flush(self) :
        self.parent.flush()
    #end flush

#+
# Handling of lists, to ensure separators only occur between items
#-

    def start_list(self) :
        "initializes handling of a list of items."
        self.first_item = True
    #end start_list

    def next_item(self, sep) :
        "Call before outputting each item. outputs sep only if there was a preceding item."
        if self.first_item :
            self.first_item = False
        else :
            self.write(sep)
        #end if
    #end next_item

    def finish_list(self, sep) :
        "Call after processing list. Outputs sep only if there was a call to next_item."
        if not self.first_item :
            self.write(sep)
        #end if
    #end finish_list

#end IndentedOutput

#+
# Useful graphics stuff
#-

def draw_centred_text(g, s) :
    "draws s into Cairo context g horizontally and vertically centred about" \
    " the current position, using the current text settings."
    extents = g.text_extents(s) # tuple: (x_bearing, y_bearing, width, height, x_advance, y_advance)
    x, y = g.get_current_point()
    g.move_to \
      (
        x - extents[2] / 2,
        y - extents[3] / 2 - extents[1]
      )
    g.show_text(s)
#end draw_centred_text

#+
# Global data
#-

cmd_prefix = None

#+
# Definitions of valid commands.
#
# Each command function is passed two arguments: the first is
# the list of positional arguments, and the second is the
# dictionary of option keywords and corresponding values
# that were specified.
#-

def cmd_help(args, opts, prefix = "", commands = None) :
    "shows the user the help description for a command, or for the help" \
    " command itself if no valid command is given."
    if commands == None :
        commands = recognized_commands
    #end if
    command_candidates = None
    command_match = None
    if len(args) == 1 :
        cmd = args[0]
        if cmd not in commands :
            command_match = cmd
            cmd = None
            command_candidates = list \
              (
                c for c in commands.keys()
                if fnmatch.fnmatch(c, command_match)
              )
        #end if
    else :
        cmd = "help"
        command_candidates = commands.keys()
    #end if
    if cmd != None :
        sys.stderr.write \
          (
                "Usage:\n\n\t%s %s%s %s\n\n%s.\n"
            %
                (
                    sys.argv[0],
                    prefix,
                    cmd,
                    commands[cmd]["help_usage"],
                    commands[cmd]["help_descr"],
                )
          )
    #end if
    if command_candidates != None :
        if len(command_candidates) != 0 :
            sys.stderr.write \
              (
                    "\nValid %(sub)scommands%(matching)s are: %(commands)s.\n"
                %
                    {
                        "sub" : ("", "sub")[commands != recognized_commands],
                        "matching" :
                            ["", " matching \"%s\"" % command_match][command_match != None],
                        "commands" : ", ".join(sorted(command_candidates)),
                    }
              )
        else :
            sys.stderr.write("No commands matching \"%s\".\n" % command_match)
        #end if
    #end if
#end cmd_help

def cmd_dgndecode(args, opts) :
    infile = args[0]
    dunge = DungeonFile.load(infile)
    out = sys.stdout
    out.write("[\n")
    out2 = IndentedOutput(out)
    out3 = IndentedOutput(out2)
    out4 = IndentedOutput(out3)
    out2.start_list()
    for dungeon in dunge :
        out2.next_item(",\n")
        out2.write("{\n")
        out3.write("\"name\":%s,\n" % json.dumps(dungeon.name))
        out3.write("\"rooms\":[\n")
        out4.start_list()
        for l in range(0, Dungeon.NR_LEVELS) :
            for s in range(0, Dungeon.NR_ROOMS_SN) :
                for e in range(0, Dungeon.NR_ROOMS_EW) :
                    room = dungeon[l, s, e]
                    out4.next_item(",\n")
                    out4.write \
                      (
                            "{\"loc\":[%d,%d,%d],\"west_side\":%s,\"north_side\":%s"
                        %
                            (
                                l,
                                s,
                                e,
                                json.dumps(room.west_side.name),
                                json.dumps(room.north_side.name),
                            )
                      )
                    if room.special != SPC.NONE :
                        out4.write(",\"spc\":%s" % json.dumps(room.special.name))
                    #end if
                    out4.write("}")
                #end for
            #end for
        #end for
        out4.finish_list("\n")
        out4.write("],\n")
        out3.write("\"start\":")
        if dungeon.start != None :
            out3.write("[%d,%d,%d]" % dungeon.start)
        else :
            out3.write("null")
        #end if
        out3.write("\n")
        out2.write("}")
    #end for
    out2.finish_list("\n")
    out.write("]\n")
    out.flush()
#end cmd_dgndecode

def cmd_dgnencode(args, opts) :

    def from_json(infile, dunge) :
        # converts a dungeon from my custom JSON format.
        jdunge = json.load(infile)
        assert type(jdunge) == list, "expecting list of dungeons"
        for jd in jdunge :
            assert type(jd) == dict, "expecting dict to define dungeon"
            assert "name" in jd and "rooms" in jd and "start" in jd, "dungeon dict must define name, rooms and start"
            d = Dungeon.new_empty(jd["name"])
            d.start = jd["start"]
            jrooms = jd["rooms"]
            assert len(jrooms) == Dungeon.NR_LEVELS * Dungeon.NR_ROOMS_SN * Dungeon.NR_ROOMS_EW, "expecting 8000 rooms"
            for l in range(0, Dungeon.NR_LEVELS) :
                for s in range(0, Dungeon.NR_ROOMS_SN) :
                    for e in range(0, Dungeon.NR_ROOMS_EW) :
                        jroom = jrooms[l * Dungeon.NR_ROOMS_SN * Dungeon.NR_ROOMS_EW + s * Dungeon.NR_ROOMS_EW + e]
                        assert jroom["loc"] == [l, s, e], "room coords mismatch"
                        room = d[l, s, e]
                        room.west_side = ROOM_SIDE.__members__[jroom["west_side"]]
                        room.north_side = ROOM_SIDE.__members__[jroom["north_side"]]
                        if "spc" in jroom :
                            room.special = SPC.__members__[jroom["spc"]]
                        else :
                            room.special = SPC.NONE
                        #end if
                    #end for
                #end for
            #end for
            dunge.append(d)
        #end for
    #end from_json

    def from_ascii(infile, dunge) :
        # converts a dungeon from the ASCII printout format as found at
        # <http://www.digital-eel.com/files/dndpage_files/DND.htm>
        # with the individual level files concatenated together.

        class DgnParseError(RuntimeError) :

            def __init__(self, msg) :
                super().__init__(msg)
            #end __init__

        #end DgnParseError

        class STATE(Enum) :
            # parse states
            EXPECT_FIRST_TITLE = 0 # dungeon name and level nr for first level
            EXPECT_TITLE = 1 # dungeon name and level nr for subsequent levels
            EXPECT_FIRST_EW_WALL = 2 # northenmost E/W wall
            EXPECT_EW_WALL = 3 # other E/W wall
            EXPECT_SN_WALL = 4 # S/N wall (3 lines)
        #end STATE

        ROOM_WIDTH = 6

        def parse_ew_wall(d, level, row, wall) :
            wall = wall.rstrip()
            if len(wall) != ROOM_WIDTH * Dungeon.NR_ROOMS_EW + 1 :
                raise DgnParseError("%d-char line wrong length for E/W wall" % len(wall))
            #end if
            if wall[ROOM_WIDTH * Dungeon.NR_ROOMS_EW] != "I" :
                raise DgnParseError("E/W wall doesn’t end in wall")
            #end if
            sides = []
            for i in range(0, Dungeon.NR_ROOMS_EW) :
                seg = wall[i * ROOM_WIDTH : (i + 1) * ROOM_WIDTH]
                if seg == "I     " or seg == "      " :
                    side = ROOM_SIDE.OPEN
                elif seg == "IIIIII" :
                    side = ROOM_SIDE.WALL
                elif seg == "II---I" :
                    side = ROOM_SIDE.DOOR
                elif seg == "II...I" :
                    side = ROOM_SIDE.RUBBLE
                else :
                    raise DgnParseError("can’t figure out E/W wall row %d, col %i: %s" % (row, i, repr(seg)))
                #end if
                sides.append(side)
            #end for
            if row < Dungeon.NR_ROOMS_SN :
                for i in range(0, Dungeon.NR_ROOMS_EW) :
                    d[level, row, i].set_side(DIR.N, sides[i])
                #end for
            else :
                for i in range(0, Dungeon.NR_ROOMS_EW) :
                    if sides[i] != ROOM_SIDE.WALL :
                        raise DgnParseError("southernmost side of level %d must be all wall" % level)
                    #end if
                #end for
            #end if
        #end parse_ew_wall

        def parse_sn_walls(d, level, row, walls) :
            if walls[0] != walls[2] :
                raise DgnParseError("S/N walls not symmetrical about centre on level %d" % level)
            #end if
            wall1 = walls[0].rstrip()
            wall2 = walls[1].rstrip()
            if wall1[ROOM_WIDTH * Dungeon.NR_ROOMS_EW] != "I" or wall2[ROOM_WIDTH * Dungeon.NR_ROOMS_EW] != "I" :
                raise DgnParseError("S/N wall doesn’t end in wall")
            #end if
            for i in range(0, Dungeon.NR_ROOMS_EW) :
                seg1 = wall1[i * ROOM_WIDTH : (i + 1) * ROOM_WIDTH]
                seg2 = wall2[i * ROOM_WIDTH : (i + 1) * ROOM_WIDTH]
                if seg1 == "      " and seg2 == "      " :
                    side = ROOM_SIDE.OPEN
                elif seg1 == "I     "  and seg2 == "I     " :
                    side = ROOM_SIDE.WALL
                elif seg1 == "I     " and seg2 == "      " :
                    side = ROOM_SIDE.DOOR
                elif seg1 == "I     " and seg2 == ":     " :
                    side = ROOM_SIDE.RUBBLE
                else :
                    raise DgnParseError("can’t figure out S/N wall row %d, col %d" % (row, i))
                #end if
                d[level, row, i].set_side(DIR.W, side)
            #end for
        #end parse_sn_walls

    #begin from_ascii
        d = None
        state = STATE.EXPECT_FIRST_TITLE
        line_nr = 0
        while True :
            line = infile.readline()
            if len(line) == 0 :
                if state != STATE.EXPECT_FIRST_TITLE :
                    raise DgnParseError("incomplete dungeon at line %d" % line_nr)
                #end if
                break
            #end if
            line_nr += 1
            line = line.rstrip("\r\n").lstrip("\x1a")
            if state in (STATE.EXPECT_FIRST_TITLE, STATE.EXPECT_TITLE) :
                line = line.rstrip()
                if len(line) != 0 :
                    splitpos = line.rfind("LEVEL")
                    if splitpos < 0 :
                        raise DgnParseError("expecting dungeon name and level nr at line %d" % line_nr)
                    #end if
                    namestr = line[:splitpos].rstrip()
                    levelstr = line[splitpos + len("LEVEL"):].lstrip().rstrip()
                    if state == STATE.EXPECT_FIRST_TITLE :
                        dungeon_name = namestr
                        d = Dungeon.new_empty(dungeon_name)
                        d.strict = False # yes, there are non-walls on other than top level
                        level = 0
                    else :
                        if dungeon_name != namestr :
                            raise DgnParseError \
                              (
                                    "dungeon name mismatch, expecting %s, got %s"
                                %
                                    (repr(dungeon_name), repr(namestr))
                              )
                        #end if
                    #end if
                    try :
                        next_level = int(levelstr)
                    except ValueError :
                        raise DgnParseError("not integer dungeon level: %s" % repr(levelstr))
                    #end if
                    if next_level != level + 1 :
                        raise DgnParseError("levels out of sequence: next level number should have been %d" % (level + 1))
                    #end if
                    state = STATE.EXPECT_FIRST_EW_WALL
                #end if
            elif state == STATE.EXPECT_FIRST_EW_WALL :
                if len(line) != 0 :
                    row = 0
                    parse_ew_wall(d, level, row, line)
                    walls = []
                    state = STATE.EXPECT_SN_WALL
                #end if
            elif state == STATE.EXPECT_EW_WALL :
                if len(line) == 0 :
                    raise DgnParseError("missing E/W wall")
                #end if
                row += 1
                parse_ew_wall(d, level, row, line)
                if row == Dungeon.NR_ROOMS_SN :
                    # finished level
                    level += 1
                    if level == Dungeon.NR_LEVELS :
                        # or at this point I could expect another entire dungeon definition
                        break
                    state = STATE.EXPECT_TITLE
                else :
                    walls = []
                    state = STATE.EXPECT_SN_WALL
                #end if
            elif state == STATE.EXPECT_SN_WALL :
                if len(line) == 0 :
                    raise DgnParseError("missing S/N wall line")
                #end if
                walls.append(line)
                if len(walls) == 3 :
                    parse_sn_walls(d, level, row, walls)
                    state = STATE.EXPECT_EW_WALL
                 #end if
            #end if
        #end while
        dunge.append(d)
    #end from_ascii

    formats = \
        {
            "json" : from_json,
            "ascii" : from_ascii,
        }

#begin cmd_dgnencode
    outfile = args[0]
    encode = from_json # default
    if "format" in opts :
        format = opts["format"]
        if format not in formats :
            raise getopt.GetoptError \
              (
                    "unrecognized input format %s -- must be one of (%s)"
                %
                    (format, ",".join(k for k in formats))
              )
        #end if
        encode = formats[format]
    #end if
    dunge = DungeonFile()
    encode(sys.stdin, dunge)
    dunge.save(outfile)
#end cmd_dgnencode

def cmd_dgnlist(args, opts) :
    dgnfile = args[0]
    dungeons = DungeonFile.load(dgnfile)
    for i, dungeon in enumerate(dungeons) :
        sys.stdout.write("%3d %s\n" % (i + 1, dungeon.name))
    #end for
#end cmd_dgnlist

def cmd_dgnmap(args, opts) :

    class map_params :
        room_width = 20.0
        room_height = 20.0
        grid_thickness = 0.5
        wall_thickness = 2.0
        door_gap = 1 / 3 # proportion of room width/height to leave for door
        map_padding = (40.0, 12.0, 12.0, 24.0) # top, right, bottom, left à la CSS
        title_y = -25.0
        title_size = 10.0
        special_size = 6.0
        row_coords_x = -15.0
        col_coords_y = -10.0

        bg_color = hsv(0, 0, 1)
        text_color = hsv(0, 0, 0)

        wall_color = hsv(0, 0, 0)
        grid_color = hsv(0.55, 0.4, 0.8)
        rubble_color = hsv(0, 0, 0.7)
        access_color = hsv(0.35, 0.3, 0.9)
        # reachable_color = hsv(0.35, 0.1, 0.95)
        unreachable_color = hsv(0.1, 0.1, 0.95)
        cannot_leave_color = hsv(0.05, 0.1, 0.95)
        one_way_in_color = hsv(0.05, 0.3, 0.9)
        prize_color = hsv(0.05, 0.9, 0.8)

        scaling = 2.0 # for better bitmap resolution
    #end map_params

    def fill_notch(x, y) :
        # fill in notch in right-angle corner in wall
        g.new_path()
        g.move_to(x - map_params.wall_thickness / 2, y - map_params.wall_thickness / 2)
        g.rel_line_to(map_params.wall_thickness, 0)
        g.rel_line_to(0, map_params.wall_thickness)
        g.rel_line_to(- map_params.wall_thickness, 0)
        g.close_path()
        g.fill()
    #end fill_notch

    def fill_room(s, e, color) :
        x = e * map_params.room_width
        y = s * map_params.room_height
        g.new_path()
        g.set_source_rgb(*color)
        g.move_to(x, y)
        g.line_to(x + map_params.room_width, y)
        g.line_to(x + map_params.room_width, y + map_params.room_height)
        g.line_to(x, y + map_params.room_height)
        g.close_path()
        g.fill()
    #end fill_room

    formats = \
        {
            ".pdf" :
                {
                    "create" : cairo.PDFSurface,
                    "multilevels" : True,
                    "scaling" : False,
                    "save" : None,
                },
            ".png" :
                {
                    "create" : cairo.ImageSurface,
                    "multilevels" : False,
                    "scaling" : True,
                    "save" : "write_to_png",
                },
            ".ps" :
                {
                    "create" : cairo.PSSurface,
                    "multilevels" : True,
                    "scaling" : False,
                    "save" : None,
                },
        }

#begin cmd_dgnmap
    dgnfile, dgnname, levels, outfile = args
    if levels.lower() == "all" :
        levels = set(range(0, Dungeon.NR_LEVELS))
        # can support more granular options in future
    else :
        levels = (int(levels),)
    #end if
    show_reachable = "show-reachable" in opts
    ext = os.path.splitext(outfile)[1]
    if ext in formats :
        format = formats[ext]
    else :
        raise getopt.GetoptError("unrecognized output extension %s" % ext)
    #end if
    if not format["multilevels"] and len(levels) != 1 :
        raise getopt.GetoptError("%s format only allows one level at a time" % ext)
    #end if
    dungeons = DungeonFile.load(dgnfile)
    dungeon = dungeons[dgnname]
    # Cairo doesn't have way to specify pixel density?
    pix = format["create"] \
      (
        (outfile, cairo.FORMAT_RGB24)[format["scaling"]],
        round((map_params.room_width * Dungeon.NR_ROOMS_EW + map_params.map_padding[1] + map_params.map_padding[3]) * (1, map_params.scaling)[format["scaling"]]), # width
        round((map_params.room_height * Dungeon.NR_ROOMS_SN + map_params.map_padding[0] + map_params.map_padding[2]) * (1, map_params.scaling)[format["scaling"]]) # height
      )
    g = cairo.Context(pix)
    if format["scaling"] :
        g.scale(map_params.scaling, map_params.scaling)
    #end if
    g.translate(map_params.map_padding[3], map_params.map_padding[0])
    if show_reachable and dungeon.start != None :
        reachable = dungeon[dungeon.start].find_connected(follow_stairs = True)
        open_rooms = set(dungeon.find_open_rooms())
        cannot_leave = set()
        one_way_in = set()
        special_directions = \
            {
                SPC.ELV : {DIR.U},
                SPC.PIT : {DIR.D},
              # following are for half-stairs--that is, no corresponding
              # return staircase in destination room
                SPC.DNS : {DIR.D},
                SPC.UDS : {DIR.D, DIR.U},
                SPC.UPS : {DIR.U},
            }
        stack = []
        connected = reachable
        is_reachable = True
        exit_room = None # actually ignored at start
        entry_room = dungeon[dungeon.start]
        exits = None
        while True :
            if exits == None :
                exits = set \
                  (
                    (room, direction)
                        for spc in special_directions
                        for room in dungeon.find_special_rooms(spc)
                        for direction in special_directions[spc]
                        if room in connected
                  )
                stack.append \
                  (
                    {
                        "connected" : connected,
                        "is_reachable" : is_reachable,
                        "exit" : exit_room, # from previous network of rooms to here
                        "entry" : entry_room, # into this network of rooms from there
                        "exits" : exits, # from this network of rooms
                    }
                  )
            #end if
            if len(exits) != 0 :
                room, direction = exits.pop()
            else :
                room = None
            #end if
            if room != None :
                entry_room = room.neighbour(direction)
                if entry_room != None :
                    if (
                                direction == DIR.U
                            and
                                room.special in (SPC.UDS, SPC.UPS)
                            and
                                entry_room.special in (SPC.DNS, SPC.UDS)
                        or
                                direction == DIR.D
                            and
                                room.special in (SPC.DNS, SPC.UDS)
                            and
                                entry_room.special in (SPC.UDS, SPC.UPS)
                    ) :
                        # full staircase--ignore
                        entry_room = None
                    #end if
                #end if
                if entry_room != None :
                    if entry_room in reachable :
                        i = len(stack)
                        while True :
                            i -= 1
                            item = stack[i]
                            if item["is_reachable"] : # always True for stack[0], so will always terminate here
                                break
                            reachable |= item["connected"]
                            item["is_reachable"] = True
                        #end while
                        is_reachable = True
                    else :
                        connected = entry_room.find_connected(follow_stairs = True)
                        i = len(stack)
                        merged_connected = False
                        while True :
                            if i == 0 : # no loop back
                                break
                            i -= 1
                            if connected <= stack[i]["connected"] :
                                assert i != 0 # else entry_room would have been in reachable
                                # loop back--merge all stack entries in-between
                                last = stack[i]
                                for j in range(i + 1, len(stack)) :
                                    last["connected"] |= stack[j]["connected"]
                                    last["exits"] |= stack[j]["exits"]
                                #end for
                                del stack[i + 1:]
                                merged_connected = True
                                break
                            #end if
                        #end while
                        if merged_connected :
                            last = stack[-1]
                            connected = last["connected"]
                            is_reachable = last["is_reachable"]
                            exits = last["exits"]
                        else :
                            is_reachable = False # to begin with
                            exit_room = room
                            exits = None # signal to push a new stack entry
                        #end if
                    #end if
                #end if
            else :
                # finished checking all exits from here
                if not is_reachable :
                    # found no way back into reachable area
                    last = stack[-1]
                    one_way_in.add(last["entry"])
                    one_way_in.add(last["exit"])
                    last["connected"].discard(last["entry"])
                    cannot_leave.update(last["connected"])
                #end if
                stack.pop()
                if len(stack) == 0 :
                    break
                last = stack[-1]
                connected = last["connected"]
                is_reachable = last["is_reachable"]
                exits = last["exits"]
            #end if
        #end while
        for room in dungeon.find_special_rooms(SPC.PIT) :
            if room in reachable and room.l + 1 == Dungeon.NR_LEVELS :
                # bottomless pit!
                reachable.remove(room)
                one_way_in.add(room)
            #end if
        #end for
    else :
        reachable = None
    #end if
    for level in range(0, Dungeon.NR_LEVELS) :
        if level in levels :
            g.set_source_rgb(*map_params.bg_color)
            g.paint()
            g.set_source_rgb(*map_params.text_color)
            g.select_font_face("sans-serif")
            g.set_font_size(map_params.title_size)
            g.move_to(map_params.room_width * Dungeon.NR_ROOMS_EW / 2, map_params.title_y)
            draw_centred_text(g, "%s — level %d" % (dgnname, level + 1))
            if reachable != None :
                for south in range(0, Dungeon.NR_ROOMS_SN) :
                    for east in range(0, Dungeon.NR_ROOMS_EW) :
                        room = dungeon[level, south, east]
                        if room in one_way_in :
                            fill_room(south, east, map_params.one_way_in_color)
                        elif room in cannot_leave :
                            fill_room(south, east, map_params.cannot_leave_color)
                        elif room in reachable  :
                            if room.special in (SPC.UPS, SPC.UDS, SPC.DNS, SPC.ELV, SPC.PIT) or room in open_rooms :
                                fill_room(south, east, map_params.access_color)
                            #end if
                        else :
                            fill_room(south, east, map_params.unreachable_color)
                        #end if
                    #end for
                #end for
                if level == dungeon.start[0] :
                    fill_room(dungeon.start[1], dungeon.start[2], map_params.access_color)
                #end if
            #end if
            g.set_source_rgb(*map_params.grid_color)
            for south in range(0, Dungeon.NR_ROOMS_SN) :
                g.move_to(map_params.row_coords_x, (south + 0.5) * map_params.room_height)
                draw_centred_text(g, "%d" % (south + 1))
            #end for
            for east in range(0, Dungeon.NR_ROOMS_EW) :
                g.move_to((east + 0.5) * map_params.room_width, map_params.col_coords_y)
                draw_centred_text(g, "%d" % (east + 1))
            #end for
            g.set_line_width(map_params.grid_thickness)
            g.new_path()
            for south in range(0, Dungeon.NR_ROOMS_SN + 1) :
                g.move_to(0, map_params.room_height * south)
                g.rel_line_to(map_params.room_width * Dungeon.NR_ROOMS_EW, 0)
            #end for
            for east in range(0, Dungeon.NR_ROOMS_EW + 1) :
                g.move_to(map_params.room_width * east, 0)
                g.rel_line_to(0, map_params.room_height * Dungeon.NR_ROOMS_SN)
            #end for
            g.stroke()
            g.set_line_width(map_params.wall_thickness)
            g.set_font_size(map_params.special_size)
            if dungeon.start != None and level == dungeon.start[0] :
                g.move_to((dungeon.start[2] + 0.5) * map_params.room_width, (dungeon.start[1] + 0.5) * map_params.room_height)
                g.set_source_rgb(*map_params.text_color)
                draw_centred_text(g, "X")
            #end if
            for south in range(0, Dungeon.NR_ROOMS_SN) :
                for east in range(0, Dungeon.NR_ROOMS_EW) :
                    room = dungeon[level, south, east]
                    if room.west_side != ROOM_SIDE.OPEN :
                        g.new_path()
                        g.move_to(east * map_params.room_width, south * map_params.room_height)
                        g.set_source_rgb(*map_params.wall_color)
                        if room.west_side == ROOM_SIDE.WALL :
                            g.rel_line_to(0, map_params.room_height)
                        elif room.west_side == ROOM_SIDE.DOOR :
                            g.rel_line_to(0, map_params.room_height * (1 - map_params.door_gap) / 2)
                            g.rel_move_to(0, map_params.room_height * map_params.door_gap)
                            g.rel_line_to(0, map_params.room_height * (1 - map_params.door_gap) / 2)
                        elif room.west_side == ROOM_SIDE.RUBBLE :
                            g.set_source_rgb(*map_params.rubble_color)
                            g.rel_line_to(0, map_params.room_height)
                        #end if
                        g.stroke()
                    #end if
                    if room.north_side != ROOM_SIDE.OPEN :
                        g.new_path()
                        g.move_to(east * map_params.room_width, south * map_params.room_height)
                        g.set_source_rgb(*map_params.wall_color)
                        if room.north_side == ROOM_SIDE.WALL :
                            g.rel_line_to(map_params.room_width, 0)
                        elif room.north_side == ROOM_SIDE.DOOR :
                            g.rel_line_to(map_params.room_width * (1 - map_params.door_gap) / 2, 0)
                            g.rel_move_to(map_params.room_width * map_params.door_gap, 0)
                            g.rel_line_to(map_params.room_width * (1 - map_params.door_gap) / 2, 0)
                        elif room.north_side == ROOM_SIDE.RUBBLE :
                            g.set_source_rgb(*map_params.rubble_color)
                            g.rel_line_to(map_params.room_width, 0)
                        #end if
                        g.stroke()
                    #end if
                    if south != 0 and east != 0 :
                        if (
                                (room.get_side(DIR.W) != ROOM_SIDE.OPEN) != (room.neighbour(DIR.N).get_side(DIR.W) != ROOM_SIDE.OPEN)
                            and
                                (room.get_side(DIR.N) != ROOM_SIDE.OPEN) != (room.neighbour(DIR.W).get_side(DIR.N) != ROOM_SIDE.OPEN)
                        ) :
                            g.set_source_rgb(*map_params.wall_color)
                            fill_notch(east * map_params.room_width, south * map_params.room_height)
                        #end if
                    #end if
                    if room.special != SPC.NONE :
                        g.move_to((east + 0.5) * map_params.room_width, (south + 0.5) * map_params.room_height)
                        g.set_source_rgb \
                          (
                            *((map_params.text_color, map_params.prize_color)[room.special in (SPC.DGN2, SPC.ORB)])
                          )
                        draw_centred_text(g, room.special.name)
                    #end if
                #end for
                g.new_path()
                g.set_source_rgb(*map_params.wall_color)
                g.move_to(map_params.room_width * Dungeon.NR_ROOMS_EW, - map_params.wall_thickness / 2)
                g.rel_line_to(0, map_params.room_height * Dungeon.NR_ROOMS_SN + map_params.wall_thickness) # easternmost wall
                g.stroke()
            #end for
            g.new_path()
            g.set_source_rgb(*map_params.wall_color)
            g.move_to(- map_params.wall_thickness / 2, map_params.room_height * Dungeon.NR_ROOMS_SN)
            g.rel_line_to(map_params.room_width * Dungeon.NR_ROOMS_EW + map_params.wall_thickness, 0) # southernmost wall
            g.stroke()
            if (
                    dungeon[level, 0, 0].get_side(DIR.W) != ROOM_SIDE.OPEN
                or
                    dungeon[level, 0, 0].get_side(DIR.N) != ROOM_SIDE.OPEN
            ) :
                fill_notch(0, 0)
            #end if
            pix.show_page()
        #end if
    #end for
    if format["save"] != None :
        pix.flush()
        getattr(pix, format["save"])(outfile)
    #end if
#end cmd_dgnmap

def cmd_dgnspecials(args, opts) :
    dgnfile = args[0]
    dgnname = args[1]
    dungeons = DungeonFile.load(dgnfile)
    try :
        dungeon = dungeons[dgnname]
    except KeyError :
        raise getopt.GetoptError("no such dungeon %s in file %s" % (repr(dgnname), dgnfile))
    #end try
    for spc in SPC :
        if spc != SPC.NONE :
            rooms = list(dungeon.find_special_rooms(spc))
            sys.stdout.write("%s: " % (spc.name))
            if len(rooms) != 0 :
                sys.stdout.write(", ".join("[%d, %d, %d]" % room.coords() for room in rooms))
            else :
                sys.stdout.write("(none)")
            #end if
            sys.stdout.write("\n")
        #end if
    #end for
#end cmd_dgnspecials

def cmd_dgnlint(args, opts) :
    dgnfile = args[0]
    dgnname = args[1]
    dungeons = DungeonFile.load(dgnfile)
    try :
        dungeon = dungeons[dgnname]
    except KeyError :
        raise getopt.GetoptError("no such dungeon %s in file %s" % (repr(dgnname), dgnfile))
    #end try
    if dungeon.start != None :
        reachable = dungeon[dungeon.start].find_connected(follow_stairs = True)
        unreachable_levels = set()
        for level in range(0, Dungeon.NR_LEVELS) :
            if all(dungeon[level, s, e] not in reachable for s in range(0, Dungeon.NR_ROOMS_SN) for e in range(0, Dungeon.NR_ROOMS_EW)) :
                unreachable_levels.add(level)
            #end if
        #end for
        if len(unreachable_levels) != 0 :
            sys.stderr.write \
              (
                    "Completely unreachable levels: %s\n"
                %
                    ",".join(str(i) for i in sorted(unreachable_levels))
              )
        #end if
    else :
        sys.stderr.write("dungeon is closed for repairs.\n")
        reachable = None
    #end if
    if next(dungeon.find_open_rooms(), None) == None :
        sys.stderr.write("dungeon has no way out.\n")
    #end if
    reported = set()
    for room in dungeon.find_special_rooms(SPC.DNS) :
        if room not in reported :
            other_room = room.neighbour(DIR.D)
            if other_room == None or other_room.special not in (SPC.UDS, SPC.UPS) :
                sys.stderr.write("room [%d,%d,%d] has down staircase with no corresponding up staircase below.\n" % room.coords())
                reported.add(room)
            #end if
        #end if
    #end for
    for room in dungeon.find_special_rooms(SPC.UPS) :
        if room not in reported :
            other_room = room.neighbour(DIR.U)
            if other_room == None or other_room.special not in (SPC.UDS, SPC.DNS) :
                sys.stderr.write("room [%d,%d,%d] has up staircase with no corresponding down staircase above.\n" % room.coords())
                reported.add(room)
            #end if
        #end if
    #end for
    for room in dungeon.find_special_rooms(SPC.UDS) :
        if room not in reported :
            other_room = room.neighbour(DIR.D)
            if other_room == None or other_room.special not in (SPC.UDS, SPC.UPS) :
                sys.stderr.write("room [%d,%d,%d] has up/down staircase with no corresponding up staircase below.\n" % room.coords())
                reported.add(room)
            #end if
            other_room = room.neighbour(DIR.U)
            if other_room == None or other_room.special not in (SPC.UDS, SPC.DNS) :
                sys.stderr.write("room [%d,%d,%d] has up/down staircase with no corresponding down staircase above.\n" % room.coords())
                reported.add(room)
            #end if
        #end if
    #end for
    orb_rooms = list(dungeon.find_special_rooms(SPC.DGN2)) + list(dungeon.find_special_rooms(SPC.ORB))
    if len(orb_rooms) == 0 :
        sys.stderr.write("dungeon has no Orb.\n")
    elif len(orb_rooms) > 1 :
        sys.stderr.write("dungeon has more than one Orb.\n")
    else :
        if reachable != None and orb_rooms[0] not in reachable :
            sys.stderr.write("room containing Orb is not reachable.\n")
        #end if
    #end if
#end cmd_dgnlint

def cmd_chrdecode(args, opts) :
    infile = args[0]
    characters = CharacterFile.load(infile)
    out = sys.stdout
    out.write("[\n")
    out2 = IndentedOutput(out)
    out3 = IndentedOutput(out2)
    out4 = IndentedOutput(out3)
    out2.start_list()
    for character in characters :
        out2.next_item(",\n")
        out2.write("{\n")
        out3.write("\"name\":%s,\n" % json.dumps(character.name))
        out3.write("\"secret_name\":%s,\n" % json.dumps(character.secret_name))
        out3.write("\"attributes\":{\n")
        out4.start_list()
        for attrib in UC :
            out4.next_item(",\n")
            out4.write("\"%s\":%d" % (attrib.name, character.attributes[attrib]))
        #end for
        out4.finish_list("\n")
        out3.write("}\n")
        out2.write("}")
    #end for
    out2.finish_list("\n")
    out.write("]\n")
    out.flush()
#end cmd_chrdecode

def cmd_chrencode(args, opts) :
    outfile = args[0]
    jchars = json.load(sys.stdin)
    assert type(jchars) == list, "expecting list of characters"
    chars = CharacterFile()
    for jchar in jchars :
        assert type(jchar) == dict, "expecting dict to define character"
        assert "name" in jchar and "secret_name" in jchar and "attributes" in jchar, \
            "character dict must define name, secret_name and attributes"
        c = Character(jchar["name"], jchar["secret_name"])
        jattribs = jchar["attributes"]
        assert type(jattribs) == dict, "expecting dict to define attributes"
        attrs_seen = set()
        for k in jattribs :
            attrib = UC.__members__[k]
            c.attributes[attrib] = jattribs[k]
            attrs_seen.add(attrib)
        #end for
        missing = []
        for k in UC :
            if not k in attrs_seen :
                missing.append(k.name)
            #end if
        #end for
        if len(missing) != 0 :
            raise ValueError("missing character attribute(s): %s" % ",".join(missing))
        #end if
        chars.append(c)
    #end for
    chars.save(outfile)
#end cmd_chrencode

def cmd_chrlist(args, opts) :
    infile = args[0]
    characters = CharacterFile.load(infile)
    for i, character in enumerate(characters) :
        if character.attributes[UC.ALIVE] :
            sys.stdout.write("%3d %s\n" % (i + 1, character.name))
        #end if
    #end for
#end cmd_chrlist

help_cmd = "help"
recognized_commands = \
  {
# key is command name, value is dictionary with following fields:
#     args -- nr required positional args, or tuple of min and max nr required positional args
#     opts -- tuple of long option names. If a name ends in an equal sign, then it takes a value.
#     multivalued -- optional tuple of option keywords which can occur multiple times
#     required -- optional tuple of option keywords which must be present
#     subcmds -- alternative to above, a dictionary of subcommands
#     help_usage -- used to construct a usage string when giving help for the command.
#     help_descr -- explanatory text shown when giving help for the command.
#     action -- the function to invoke to actually perform the command.

    "help" :
      {
        "args" : (0, 1),
        "opts" : (),
        "action" : cmd_help,
        "help_usage" : "[cmd]",
        "help_descr" : "gives help about the specified command",
      },

    "dgn" :
      {
        "subcmds" :
          {
            "decode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_dgndecode,
                "help_usage" : "dgnfile",
                "help_descr" : "converts a dungeon file to JSON format to stdout",
              },

            "encode" :
              {
                "args" : 1,
                "opts" : ("format=",),
                "action" : cmd_dgnencode,
                "help_usage" : "[--format=format] dgnfile",
                "help_descr" : "generates a dungeon file from JSON format from stdin",
              },

            "lint" :
              {
                "args" : 2,
                "opts" : (),
                "action" : cmd_dgnlint,
                "help_usage" : "dgnfile dgnname",
                "help_descr" : "does some basic checks on the consistency of a dungeon",
              },

            "list" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_dgnlist,
                "help_usage" : "dgnfile",
                "help_descr": "lists the names of the dungeons in the specified dungeon file",
              },

            "map" :
              {
                "args" : 4,
                "opts" : ("show-reachable",),
                "action" : cmd_dgnmap,
                "help_usage" : "dgnfile dgnname level outfile",
                "help_descr" :
                    "generates a map in PDF, PNG or PostScript format of the specified level of the specified dungeon",
              },

            "specials" :
              {
                "args" : 2,
                "opts" : (),
                "action" : cmd_dgnspecials,
                "help_usage" : "dgnfile dgnname",
                "help_descr" : "lists special room contents for the specified dungeon in the specified file",
              },
          },
        "help_descr" : "invokes subcommands for managing dungeon level files",
      },

    "chr" :
      {
        "subcmds" :
          {
            "decode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrdecode,
                "help_usage" : "chrfile",
                "help_descr" : "converts a character file to JSON format to stdout",
              },

            "encode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrencode,
                "help_usage" : "chrfile",
                "help_descr" : "generates a character file from JSON format from stdin",
              },

            "list" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrlist,
                "help_usage" : "chrfile",
                "help_descr" : "lists the names of the characters in the specified character file",
              },
          },
        "help_descr" : "invokes subcommands for managing character files",
      },
  }

def complete_recognized_commands() :
    # gives every subcommand a help entry.

    class subcmd_help :
        # for saving a subcommand context for passing to cmd_help.
        def __init__(self, prefix, subcmds) :
            self.prefix = prefix
            self.subcmds = subcmds
        #end __init__
        def __call__(self, args, opts) :
            cmd_help(args, opts, self.prefix, self.subcmds)
        #end __call__
    #end subcmd_help

#begin complete_recognized_commands
    for cmd in recognized_commands :
        cmd_entry = recognized_commands[cmd]
        if "subcmds" in cmd_entry :
            subhelp = dict(recognized_commands[help_cmd])
            subhelp["action"] = subcmd_help(cmd + " ", cmd_entry["subcmds"])
            subhelp["help_usage"] = "[subcmd]"
            subhelp["help_descr"] = "gives help about the specified subcommand"
            cmd_entry["subcmds"][help_cmd] = subhelp
            cmd_entry["help_usage"] = "subcmd"
        #end if
    #end for
#end complete_recognized_commands

complete_recognized_commands()
del complete_recognized_commands # your work is done

#+
# Mainline
#-

def mainline() :
    global cmd_prefix
    if len(sys.argv) < 2 :
        raise getopt.GetoptError("need at least one arg, the command to execute")
    #end if
    cmd = sys.argv[1]
    cmd_entry = recognized_commands.get(cmd)
    if cmd_entry == None :
        raise getopt.GetoptError("unrecognized command %s" % repr(cmd))
    #end if
    if "subcmds" in cmd_entry :
        if len(sys.argv) < 3 :
            raise getopt.GetoptError \
              (
                "%s command needs at least one more arg, the subcommand to execute" % cmd
              )
        #end if
        cmd_rest = sys.argv[3:]
        subcmd = sys.argv[2]
        cmd_entry = cmd_entry["subcmds"].get(subcmd)
        if cmd_entry == None :
            raise getopt.GetoptError("unrecognized %s subcommand %s" % (cmd, repr(subcmd)))
        #end if
        cmd_prefix = "%s %s" % (cmd, subcmd)
    else :
        cmd_rest = sys.argv[2:]
        subcmd = None
        cmd_prefix = cmd
    #end if
    opts_list, args = getopt.gnu_getopt(cmd_rest, "", cmd_entry["opts"])
    if type(cmd_entry["args"]) == tuple :
        if (
                len(cmd_entry["args"]) == 2
            and
                (
                    len(args) < cmd_entry["args"][0]
                or
                    len(args) > cmd_entry["args"][1]
                )
        ) :
            raise getopt.GetoptError \
              (
                "%s command needs %u..%u args" % ((cmd_prefix,) + cmd_entry["args"])
              )
        #end if
    else :
        if len(args) != cmd_entry["args"] :
            raise getopt.GetoptError \
              (
                "%s command needs exactly %u args" % (cmd_prefix, cmd_entry["args"])
              )
        #end if
    #end if
    opts = {}
    multi_opts = frozenset(cmd_entry.get("multivalued", ()))
    for keyword, value in opts_list :
        if keyword[:2] == "--" :
            keyword = keyword[2:]
            if keyword in multi_opts :
                values = opts.get(keyword, [])
                values.append(value)
                opts[keyword] = values
            else :
                opts[keyword] = value
            #end if
        #end if
    #end for
    required_opts = cmd_entry.get("required")
    if required_opts != None :
        missing = set(required_opts) - set(opts.keys())
        if len(missing) != 0 :
            raise getopt.GetoptError \
              (
                "%s command needs option(s) %s" % (cmd_prefix, ",".join(tuple(missing)))
              )
        #end if
    #end if
    cmd_entry["action"](args, opts) # can raise exceptions
#end mainline

mainline()
