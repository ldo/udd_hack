#!/usr/bin/python3
#+
# Tool to commit hacks on dungeon and character files for udd <https://github.com/ldo/udd>.
# Invoke as
#
#     dunhack <cmd> ...
#
# to execute a command. Type
#
#     dunhack help
#
# for an overview of available commands.
#
# Copyright 2014 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import json
import fnmatch
import getopt
from dungeon import \
    Character, \
    CharacterFile, \
    Dungeon, \
    DungeonFile

#+
# JSON representation
#-

class IndentedOutput :
    "wrapper for an output text stream that prepends indentation onto every line." \
    " Can be used to wrap another instance of itself for nested indentation. Just" \
    " donâ€™t switch streams in the middle of a line."

    indent = 4 * " "

    def __init__(self, parent) :
        self.parent = parent
        self.sol = True
    #end __init__

    def write(self, s) :
        while len(s) != 0 :
            if self.sol :
                self.parent.write(self.indent)
            #end if
            eol = s.find("\n")
            self.sol = eol >= 0
            if self.sol :
                eol += 1 # include newline
            else :
                eol = len(s)
            #end if
            self.parent.write(s[:eol])
            s = s[eol:]
        #end while
    #end write

    def flush(self) :
        self.parent.flush()
    #end flush

#+
# Handling of lists, to ensure separators only occur between items
#-

    def start_list(self) :
        "initializes handling of a list of items."
        self.first_item = True
    #end start_list

    def next_item(self, sep) :
        "Call before outputting each item. outputs sep only if there was a preceding item."
        if self.first_item :
            self.first_item = False
        else :
            self.write(sep)
        #end if
    #end next_item

    def finish_list(self, sep) :
        "Call after processing list. Outputs sep only if there was a call to next_item."
        if not self.first_item :
            self.write(sep)
        #end if
    #end finish_list

#end IndentedOutput

#+
# Global data
#-

cmd_prefix = None

#+
# Definitions of valid commands.
#
# Each command function is passed two arguments: the first is
# the list of positional arguments, and the second is the
# dictionary of option keywords and corresponding values
# that were specified.
#-

def cmd_help(args, opts, prefix = "", commands = None) :
    "shows the user the help description for a command, or for the help" \
    " command itself if no valid command is given."
    if commands == None :
        commands = recognized_commands
    #end if
    command_candidates = None
    command_match = None
    if len(args) == 1 :
        cmd = args[0]
        if cmd not in commands :
            command_match = cmd
            cmd = None
            command_candidates = list \
              (
                c for c in commands.keys()
                if fnmatch.fnmatch(c, command_match)
              )
        #end if
    else :
        cmd = "help"
        command_candidates = commands.keys()
    #end if
    if cmd != None :
        sys.stderr.write \
          (
                "Usage:\n\n\t%s %s%s %s\n\n%s.\n"
            %
                (
                    sys.argv[0],
                    prefix,
                    cmd,
                    commands[cmd]["help_usage"],
                    commands[cmd]["help_descr"],
                )
          )
    #end if
    if command_candidates != None :
        if len(command_candidates) != 0 :
            sys.stderr.write \
              (
                    "\nValid %(sub)scommands%(matching)s are: %(commands)s.\n"
                %
                    {
                        "sub" : ("", "sub")[commands != recognized_commands],
                        "matching" :
                            ["", " matching \"%s\"" % command_match][command_match != None],
                        "commands" : ", ".join(sorted(command_candidates)),
                    }
              )
        else :
            sys.stderr.write("No commands matching \"%s\".\n" % command_match)
        #end if
    #end if
#end cmd_help

def cmd_dgntojson(args, opts) :
    infile = args[0]
    dunge = DungeonFile.load(infile)
    out = sys.stdout
    out.write("[\n")
    out2 = IndentedOutput(out)
    out3 = IndentedOutput(out2)
    out4 = IndentedOutput(out3)
    out2.start_list()
    for dungeon in dunge :
        out2.next_item(",\n")
        out2.write("{\n")
        out3.write("\"name\":%s,\n" % json.dumps(dungeon.name))
        out3.write("\"rooms\":[\n")
        out4.start_list()
        for l in range(0, 20) :
            for s in range(0, 20) :
                for e in range(0, 20) :
                    room = dungeon[l, s, e]
                    out4.next_item(",\n")
                    out4.write \
                      (
                            "{\"loc\":[%d,%d,%d],\"west_side\":%s,\"north_side\":%s"
                        %
                            (
                                l,
                                s,
                                e,
                                json.dumps(room.west_side.name),
                                json.dumps(room.north_side.name),
                            )
                      )
                    if room.special != Dungeon.SPC.NONE :
                        out4.write(",\"spc\":%s" % json.dumps(room.special.name))
                    #end if
                    out4.write("}")
                #end for
            #end for
        #end for
        out4.finish_list("\n")
        out4.write("],\n")
        out3.write("\"start\":")
        if dungeon.start != None :
            out3.write("[%d,%d,%d]" % dungeon.start)
        else :
            out3.write("null")
        #end if
        out3.write("\n")
        out2.write("}")
    #end for
    out2.finish_list("\n")
    out.write("]\n")
    out.flush()
#end cmd_dgntojson

def cmd_dgnfromjson(args, opts) :
    outfile = args[0]
    jdunge = json.load(sys.stdin)
    assert type(jdunge) == list, "expecting list of dungeons"
    dunge = DungeonFile()
    for jd in jdunge :
        assert type(jd) == dict, "expecting dict to define dungeon"
        assert "name" in jd and "rooms" in jd and "start" in jd, "dungeon dict must define name, rooms and start"
        d = Dungeon.new_empty(jd["name"])
        d.start = jd["start"]
        jrooms = jd["rooms"]
        assert len(jrooms) == 8000, "expecting 8000 rooms"
        for l in range(0, 20) :
            for s in range(0, 20) :
                for e in range(0, 20) :
                    jroom = jrooms[l * 400 + s * 20 + e]
                    assert jroom["loc"] == [l, s, e], "room coords mismatch"
                    room = d[l, s, e]
                    room.west_side = Dungeon.ROOM_SIDE.__members__[jroom["west_side"]]
                    room.north_side = Dungeon.ROOM_SIDE.__members__[jroom["north_side"]]
                    if "spc" in jroom :
                        room.special = Dungeon.SPC.__members__[jroom["spc"]]
                    else :
                        room.special = Dungeon.SPC.NONE
                    #end if
                #end for
            #end for
        #end for
        dunge.append(d)
    #end for
    dunge.save(outfile)
#end cmd_dgnfromjson

def cmd_dgnlist(args, opts) :
    infile = args[0]
    dungeons = DungeonFile.load(infile)
    for i, dungeon in enumerate(dungeons) :
        sys.stdout.write("%3d %s\n" % (i + 1, dungeon.name))
    #end for
#end cmd_dgnlist

def cmd_chrtojson(args, opts) :
    infile = args[0]
    characters = CharacterFile.load(infile)
    out = sys.stdout
    out.write("[\n")
    out2 = IndentedOutput(out)
    out3 = IndentedOutput(out2)
    out4 = IndentedOutput(out3)
    out2.start_list()
    for character in characters :
        out2.next_item(",\n")
        out2.write("{\n")
        out3.write("\"name\":%s,\n" % json.dumps(character.name))
        out3.write("\"secret_name\":%s,\n" % json.dumps(character.secret_name))
        out3.write("\"attributes\":{\n")
        out4.start_list()
        for attrib in Character.UC :
            out4.next_item(",\n")
            out4.write("\"%s\":%d" % (attrib.name, character.attributes[attrib]))
        #end for
        out4.finish_list("\n")
        out3.write("}\n")
        out2.write("}")
    #end for
    out2.finish_list("\n")
    out.write("]\n")
    out.flush()
#end cmd_chrtojson

def cmd_chrfromjson(args, opts) :
    outfile = args[0]
    jchars = json.load(sys.stdin)
    assert type(jchars) == list, "expecting list of characters"
    chars = CharacterFile()
    for jchar in jchars :
        assert type(jchar) == dict, "expecting dict to define character"
        assert "name" in jchar and "secret_name" in jchar and "attributes" in jchar, \
            "character dict must define name, secret_name and attributes"
        c = Character(jchar["name"], jchar["secret_name"])
        jattribs = jchar["attributes"]
        assert type(jattribs) == dict, "expecting dict to define attributes"
        attrs_seen = set()
        for k in jattribs :
            attrib = Character.UC.__members__[k]
            c.attributes[attrib] = jattribs[k]
            attrs_seen.add(attrib)
        #end for
        missing = []
        for k in Character.UC :
            if not k in attrs_seen :
                missing.append(k.name)
            #end if
        #end for
        if len(missing) != 0 :
            raise ValueError("missing character attribute(s): %s" % ",".join(missing))
        #end if
        chars.append(c)
    #end for
    chars.save(outfile)
#end cmd_chrfromjson

def cmd_chrlist(args, opts) :
    infile = args[0]
    characters = CharacterFile.load(infile)
    for i, character in enumerate(characters) :
        if character.attributes[Character.UC.ALIVE] :
            sys.stdout.write("%3d %s\n" % (i + 1, character.name))
        #end if
    #end for
#end cmd_chrlist

help_cmd = "help"
recognized_commands = \
  {
# key is command name, value is dictionary with following fields:
#     args -- nr required positional args, or tuple of min and max nr required positional args
#     opts -- tuple of long option names. If a name ends in an equal sign, then it takes a value.
#     multivalued -- optional tuple of option keywords which can occur multiple times
#     required -- optional tuple of option keywords which must be present
#     subcmds -- alternative to above, a dictionary of subcommands
#     help_usage -- used to construct a usage string when giving help for the command.
#     help_descr -- explanatory text shown when giving help for the command.
#     action -- the function to invoke to actually perform the command.

    "help" :
      {
        "args" : (0, 1),
        "opts" : (),
        "action" : cmd_help,
        "help_usage" : "[cmd]",
        "help_descr" : "gives help about the specified command",
      },

    "dgn" :
      {
        "subcmds" :
          {
            "decode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_dgntojson,
                "help_usage" : "dgnfile",
                "help_descr" : "converts a dungeon file to JSON format to stdout",
              },

            "encode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_dgnfromjson,
                "help_usage" : "dgnfile",
                "help_descr" : "generates a dungeon file from JSON format from stdin",
              },

            "list" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_dgnlist,
                "help_usage" : "dgnfile",
                "help_descr": "lists the names of the dungeons in the specified dungeon file",
              },
          },
        "help_descr" : "invokes subcommands for managing dungeon level files",
      },

    "chr" :
      {
        "subcmds" :
          {
            "decode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrtojson,
                "help_usage" : "chrfile",
                "help_descr" : "converts a character file to JSON format to stdout",
              },

            "encode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrfromjson,
                "help_usage" : "chrfile",
                "help_descr" : "generates a character file from JSON format from stdin",
              },

            "list" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrlist,
                "help_usage" : "chrfile",
                "help_descr" : "lists the names of the characters in the specified character file",
              },
          },
        "help_descr" : "invokes subcommands for managing character files",
      },
  }

def complete_recognized_commands() :
    # gives every subcommand a help entry.

    class subcmd_help :
        # for saving a subcommand context for passing to cmd_help.
        def __init__(self, prefix, subcmds) :
            self.prefix = prefix
            self.subcmds = subcmds
        #end __init__
        def __call__(self, args, opts) :
            cmd_help(args, opts, self.prefix, self.subcmds)
        #end __call__
    #end subcmd_help

#begin complete_recognized_commands
    for cmd in recognized_commands :
        cmd_entry = recognized_commands[cmd]
        if "subcmds" in cmd_entry :
            subhelp = dict(recognized_commands[help_cmd])
            subhelp["action"] = subcmd_help(cmd + " ", cmd_entry["subcmds"])
            subhelp["help_usage"] = "[subcmd]"
            subhelp["help_descr"] = "gives help about the specified subcommand"
            cmd_entry["subcmds"][help_cmd] = subhelp
            cmd_entry["help_usage"] = "subcmd"
        #end if
    #end for
#end complete_recognized_commands

complete_recognized_commands()
del complete_recognized_commands # your work is done

#+
# Mainline
#-

def mainline() :
    global cmd_prefix
    if len(sys.argv) < 2 :
        raise getopt.GetoptError("need at least one arg, the command to execute")
    #end if
    cmd = sys.argv[1]
    cmd_entry = recognized_commands.get(cmd)
    if cmd_entry == None :
        raise getopt.GetoptError("unrecognized command %s" % repr(cmd))
    #end if
    if "subcmds" in cmd_entry :
        if len(sys.argv) < 3 :
            raise getopt.GetoptError \
              (
                "%s command needs at least one more arg, the subcommand to execute" % cmd
              )
        #end if
        cmd_rest = sys.argv[3:]
        subcmd = sys.argv[2]
        cmd_entry = cmd_entry["subcmds"].get(subcmd)
        if cmd_entry == None :
            raise getopt.GetoptError("unrecognized %s subcommand %s" % (cmd, repr(subcmd)))
        #end if
        cmd_prefix = "%s %s" % (cmd, subcmd)
    else :
        cmd_rest = sys.argv[2:]
        subcmd = None
        cmd_prefix = cmd
    #end if
    opts_list, args = getopt.gnu_getopt(cmd_rest, "", cmd_entry["opts"])
    if type(cmd_entry["args"]) == tuple :
        if (
                len(cmd_entry["args"]) == 2
            and
                (
                    len(args) < cmd_entry["args"][0]
                or
                    len(args) > cmd_entry["args"][1]
                )
        ) :
            raise getopt.GetoptError \
              (
                "%s command needs %u..%u args" % ((cmd_prefix,) + cmd_entry["args"])
              )
        #end if
    else :
        if len(args) != cmd_entry["args"] :
            raise getopt.GetoptError \
              (
                "%s command needs exactly %u args" % (cmd_prefix, cmd_entry["args"])
              )
        #end if
    #end if
    opts = {}
    multi_opts = frozenset(cmd_entry.get("multivalued", ()))
    for keyword, value in opts_list :
        if keyword[:2] == "--" :
            keyword = keyword[2:]
            if keyword in multi_opts :
                values = opts.get(keyword, [])
                values.append(value)
                opts[keyword] = values
            else :
                opts[keyword] = value
            #end if
        #end if
    #end for
    required_opts = cmd_entry.get("required")
    if required_opts != None :
        missing = set(required_opts) - set(opts.keys())
        if len(missing) != 0 :
            raise getopt.GetoptError \
              (
                "%s command needs option(s) %s" % (cmd_prefix, ",".join(tuple(missing)))
              )
        #end if
    #end if
    cmd_entry["action"](args, opts) # can raise exceptions
#end mainline

mainline()
