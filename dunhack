#!/usr/bin/python3
#+
# Tool to commit hacks on dungeon and character files for udd. Invoke as
#
#     dunhack <cmd> ...
#
# to invoke a command. Type
#
#     dunhack help
#
# for an overview of available commands.
#
# Copyright 2014 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import json
import getopt
from dungeon import \
    Character, \
    CharacterFile, \
    Dungeon, \
    DungeonFile

#+
# JSON representation
#-

class IndentedOutput :
    "wrapper for an output text stream that prepends indentation onto every line." \
    " Can be used to wrap another instance of itself for nested indentation. Just" \
    " donâ€™t switch streams in the middle of a line."

    indent = 4 * " "

    def __init__(self, parent) :
        self.parent = parent
        self.sol = True
    #end __init__

    def write(self, s) :
        while len(s) != 0 :
            if self.sol :
                self.parent.write(self.indent)
            #end if
            eol = s.find("\n")
            self.sol = eol >= 0
            if self.sol :
                eol += 1 # include newline
            else :
                eol = len(s)
            #end if
            self.parent.write(s[:eol])
            s = s[eol:]
        #end while
    #end write

    def flush(self) :
        self.parent.flush()
    #end flush

#+
# Handling of lists, to ensure separators only occur between items
#-

    def start_list(self) :
        "initializes handling of a list of items."
        self.first_item = True
    #end start_list

    def next_item(self, sep) :
        "Call before outputting each item. outputs sep only if there was a preceding item."
        if self.first_item :
            self.first_item = False
        else :
            self.write(sep)
        #end if
    #end next_item

    def finish_list(self, sep) :
        "Call after processing list. Outputs sep only if there was a call to next_item."
        if not self.first_item :
            self.write(sep)
        #end if
    #end finish_list

#end IndentedOutput

#+
# Definitions of valid commands.
#
# Each command function is passed two arguments: the first is
# the list of positional arguments, and the second is the
# dictionary of option keywords and corresponding values
# that were specified.
#-

def cmd_help(args, opts) :
    """shows the user the help description for a command, or for the help
    command itself if no valid command is given."""
    command_candidates = None
    command_match = None
    if len(args) == 1 :
        cmd = args[0]
        if cmd not in recognized_commands :
            command_match = cmd
            cmd = None
            command_candidates = list \
              (
                c for c in recognized_commands.keys()
                if fnmatch.fnmatch(c, command_match)
              )
        #end if
    else :
        cmd = "help"
        command_candidates = recognized_commands.keys()
    #end if
    if cmd != None :
        sys.stderr.write \
          (
                "Usage:\n\n\t%s %s %s\n\n%s.\n"
            %
                (
                    sys.argv[0],
                    cmd,
                    recognized_commands[cmd]["help_usage"],
                    recognized_commands[cmd]["help_descr"],
                )
          )
    #end if
    if command_candidates != None :
        if len(command_candidates) != 0 :
            sys.stderr.write \
              (
                    "\nValid commands%(matching)s are: %(commands)s.\n"
                %
                    {
                        "matching" :
                            ["", " matching \"%s\"" % command_match][command_match != None],
                        "commands" : ", ".join(sorted(command_candidates)),
                    }
              )
        else :
            sys.stderr.write("No commands matching \"%s\".\n" % command_match)
        #end if
    #end if
#end cmd_help

def cmd_dgntojson(args, opts) :
    infile = args[0]
    outfile = args[1]
    dunge = DungeonFile.load(infile)
    out = open(outfile, "w")
    out.write("[\n")
    out2 = IndentedOutput(out)
    out3 = IndentedOutput(out2)
    out4 = IndentedOutput(out3)
    out2.start_list()
    for dungeon in dunge :
        out2.next_item(",\n")
        out2.write("{\n")
        out3.write("\"name\":%s,\n" % json.dumps(dungeon.name))
        out3.write("\"rooms\":[\n")
        out4.start_list()
        for l in range(0, 20) :
            for s in range(0, 20) :
                for e in range(0, 20) :
                    room = dungeon[l, s, e]
                    out4.next_item(",\n")
                    out4.write \
                      (
                            "{\"loc\":[%d,%d,%d],\"west_side\":%s,\"north_side\":%s"
                        %
                            (
                                l,
                                s,
                                e,
                                json.dumps(room.west_side.name),
                                json.dumps(room.north_side.name),
                            )
                      )
                    if room.special != Dungeon.SPC.NONE :
                        out4.write(",\"spc\":%s" % json.dumps(room.special.name))
                    #end if
                    out4.write("}")
                #end for
            #end for
        #end for
        out4.finish_list("\n")
        out4.write("],\n")
        out3.write("\"start\":")
        if dungeon.start != None :
            out3.write("[%d,%d,%d]" % dungeon.start)
        else :
            out3.write("null")
        #end if
        out3.write("\n")
        out2.write("}")
    #end for
    out2.finish_list("\n")
    out.write("]\n")
    out.flush()
#end cmd_dgntojson

def cmd_dgnfromjson(args, opts) :
    infile = args[0]
    outfile = args[1]
    jdunge = json.load(open(infile, "r"))
    assert type(jdunge) == list, "expecting list of dungeons"
    dunge = DungeonFile()
    for jd in jdunge :
        assert type(jd) == dict, "expecting dict to define dungeon"
        assert "name" in jd and "rooms" in jd and "start" in jd, "dungeon dict must define name, rooms and start"
        d = Dungeon.new_empty(jd["name"])
        d.start = jd["start"]
        jrooms = jd["rooms"]
        assert len(jrooms) == 8000, "expecting 8000 rooms"
        for l in range(0, 20) :
            for s in range(0, 20) :
                for e in range(0, 20) :
                    jroom = jrooms[l * 400 + s * 20 + e]
                    assert jroom["loc"] == [l, s, e], "room coords mismatch"
                    room = d[l, s, e]
                    room.west_side = Dungeon.ROOM_SIDE.__members__[jroom["west_side"]]
                    room.north_side = Dungeon.ROOM_SIDE.__members__[jroom["north_side"]]
                    if "spc" in jroom :
                        room.special = Dungeon.SPC.__members__[jroom["spc"]]
                    else :
                        room.special = Dungeon.SPC.NONE
                    #end if
                #end for
            #end for
        #end for
        dunge.append(d)
    #end for
    dunge.save(outfile)
#end cmd_dgnfromjson

def cmd_chrtojson(args, opts) :
    infile = args[0]
    outfile = args[1]
    characters = CharacterFile.load(infile)
    out = open(outfile, "w")
    out.write("[\n")
    out2 = IndentedOutput(out)
    out3 = IndentedOutput(out2)
    out4 = IndentedOutput(out3)
    out2.start_list()
    for character in characters :
        out2.next_item(",\n")
        out2.write("{\n")
        out3.write("\"name\":%s,\n" % json.dumps(character.name))
        out3.write("\"secret_name\":%s,\n" % json.dumps(character.secret_name))
        out3.write("\"attributes\":{\n")
        out4.start_list()
        for attrib in Character.UC :
            out4.next_item(",\n")
            out4.write("\"%s\":%d" % (attrib.name, character.attributes[attrib]))
        #end for
        out4.finish_list("\n")
        out3.write("}\n")
        out2.write("}")
    #end for
    out2.finish_list("\n")
    out.write("]\n")
    out.flush()
#end cmd_chrtojson

def cmd_chrfromjson(args, opts) :
    infile = args[0]
    outfile = args[1]
    jchars = json.load(open(infile, "r"))
    assert type(jchars) == list, "expecting list of characters"
    chars = CharacterFile()
    for jchar in jchars :
        assert type(jchar) == dict, "expecting dict to define character"
        assert "name" in jchar and "secret_name" in jchar and "attributes" in jchar, \
            "character dict must define name, secret_name and attributes"
        c = Character(jchar["name"], jchar["secret_name"])
        jattribs = jchar["attributes"]
        assert type(jattribs) == dict, "expecting dict to define attributes"
        attrs_seen = set()
        for k in jattribs :
            attrib = Character.UC.__members__[k]
            c.attributes[attrib] = jattribs[k]
            attrs_seen.add(attrib)
        #end for
        missing = []
        for k in Character.UC :
            if not k in attrs_seen :
                missing.append(k.name)
            #end if
        #end for
        if len(missing) != 0 :
            raise ValueError("missing character attribute(s): %s" % ",".join(missing))
        #end if
        chars.append(c)
    #end for
    chars.save(outfile)
#end cmd_chrfromjson

recognized_commands = \
  {
# key is command name, value is dictionary with following fields:
#     args -- nr required positional args, or tuple of min and max nr required positional args
#     opts -- tuple of long option names. If a name ends in an equal sign, then it takes a value.
#     multivalued -- optional tuple of option keywords which can occur multiple times
#     required -- optional tuple of option keywords which must be present
#     help_usage -- used to construct a usage string when giving help for the command.
#     help_descr -- explanatory text shown when giving help for the command.
#     action -- the function to invoke to actually perform the command.

    "help" :
      {
        "args" : (0, 1),
        "opts" : (),
        "action" : cmd_help,
        "help_usage" : "[cmd]",
        "help_descr" : "gives help about the specified command",
      },

    "dgntojson" :
      {
        "args" : 2,
        "opts" : (),
        "action" : cmd_dgntojson,
        "help_usage" : "dgnfile jsonfile",
        "help_descr" : "converts a dungeon file to JSON format",
      },

    "dgnfromjson" :
      {
        "args" : 2,
        "opts" : (),
        "action" : cmd_dgnfromjson,
        "help_usage" : "jsonfile dgnfile",
        "help_descr" : "generates a dungeon file from JSON format",
      },

    "chrtojson" :
      {
        "args" : 2,
        "opts" : (),
        "action" : cmd_chrtojson,
        "help_usage" : "chrfile jsonfile",
        "help_descr" : "converts a character file to JSON format",
      },

    "chrfromjson" :
      {
        "args" : 2,
        "opts" : (),
        "action" : cmd_chrfromjson,
        "help_usage" : "jsonfile chrfile",
        "help_descr" : "generates a character file from JSON format",
      },
  }

#+
# Mainline
#-

def mainline() :
    if len(sys.argv) < 2 :
        raise getopt.GetoptError("need at least one arg, the cmd to execute")
    #end if
    cmd = sys.argv[1]
    cmd_entry = recognized_commands.get(cmd)
    if cmd_entry == None :
        raise getopt.GetoptError("unrecognized command %s" % repr(cmd))
    #end if
    (opts_list, args) = getopt.gnu_getopt \
      (
        sys.argv[2:],
        "",
        cmd_entry["opts"]
      )
    if type(cmd_entry["args"]) == tuple :
        if \
          (
                len(args) < cmd_entry["args"][0]
            or
                len(args) > cmd_entry["args"][1]
          ):
            raise getopt.GetoptError \
              (
                "%s command needs %u..%u args" % ((cmd,) + cmd_entry["args"])
              )
        #end if
    else :
        if len(args) != cmd_entry["args"] :
            raise getopt.GetoptError \
              (
                "%s command needs exactly %u args" % (cmd, cmd_entry["args"])
              )
        #end if
    #end if
    opts = {}
    multi_opts = frozenset(cmd_entry.get("multivalued", ()))
    for keyword, value in opts_list :
        if keyword[:2] == "--" :
            keyword = keyword[2:]
            if keyword in multi_opts :
                values = opts.get(keyword, [])
                values.append(value)
                opts[keyword] = values
            else :
                opts[keyword] = value
            #end if
        #end if
    #end for
    required_opts = cmd_entry.get("required")
    if required_opts != None :
        missing = set(required_opts) - set(opts.keys())
        if len(missing) != 0 :
            raise getopt.GetoptError \
              (
                "%s command needs option(s) %s" % (cmd, ",".join(tuple(missing)))
              )
        #end if
    #end if
    cmd_entry["action"](args, opts) # can raise exceptions
#end mainline

mainline()
