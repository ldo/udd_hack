#!/usr/bin/python3
#+
# Tool to commit hacks on dungeon and character files for udd <https://github.com/ldo/udd>.
# Invoke as
#
#     dunhack <cmd> ...
#
# to execute a command. Type
#
#     dunhack help
#
# for an overview of available commands.
#
# Copyright 2014 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import cairo
import colorsys
import json
import fnmatch
import getopt
from dungeon import \
    DIR, \
    Character, \
    CharacterFile, \
    Dungeon, \
    DungeonFile
SPC = Dungeon.SPC
ROOM_SIDE = Dungeon.ROOM_SIDE
UC = Character.UC

#+
# JSON representation
#-

class IndentedOutput :
    "wrapper for an output text stream that prepends indentation onto every line." \
    " Can be used to wrap another instance of itself for nested indentation. Just" \
    " don’t switch streams in the middle of a line."

    indent = 4 * " "

    def __init__(self, parent) :
        self.parent = parent
        self.sol = True
    #end __init__

    def write(self, s) :
        while len(s) != 0 :
            if self.sol :
                self.parent.write(self.indent)
            #end if
            eol = s.find("\n")
            self.sol = eol >= 0
            if self.sol :
                eol += 1 # include newline
            else :
                eol = len(s)
            #end if
            self.parent.write(s[:eol])
            s = s[eol:]
        #end while
    #end write

    def flush(self) :
        self.parent.flush()
    #end flush

#+
# Handling of lists, to ensure separators only occur between items
#-

    def start_list(self) :
        "initializes handling of a list of items."
        self.first_item = True
    #end start_list

    def next_item(self, sep) :
        "Call before outputting each item. outputs sep only if there was a preceding item."
        if self.first_item :
            self.first_item = False
        else :
            self.write(sep)
        #end if
    #end next_item

    def finish_list(self, sep) :
        "Call after processing list. Outputs sep only if there was a call to next_item."
        if not self.first_item :
            self.write(sep)
        #end if
    #end finish_list

#end IndentedOutput

#+
# Useful graphics stuff
#-

def draw_centred_text(g, s) :
    "draws s into Cairo context g using the current position and text settings."
    extents = g.text_extents(s) # tuple: (x_bearing, y_bearing, width, height, x_advance, y_advance)
    x, y = g.get_current_point()
    g.move_to \
      (
        x - extents[2] / 2,
        y - extents[3] / 2 - extents[1]
      )
    g.show_text(s)
#end draw_centred_text

#+
# Global data
#-

cmd_prefix = None

#+
# Definitions of valid commands.
#
# Each command function is passed two arguments: the first is
# the list of positional arguments, and the second is the
# dictionary of option keywords and corresponding values
# that were specified.
#-

def cmd_help(args, opts, prefix = "", commands = None) :
    "shows the user the help description for a command, or for the help" \
    " command itself if no valid command is given."
    if commands == None :
        commands = recognized_commands
    #end if
    command_candidates = None
    command_match = None
    if len(args) == 1 :
        cmd = args[0]
        if cmd not in commands :
            command_match = cmd
            cmd = None
            command_candidates = list \
              (
                c for c in commands.keys()
                if fnmatch.fnmatch(c, command_match)
              )
        #end if
    else :
        cmd = "help"
        command_candidates = commands.keys()
    #end if
    if cmd != None :
        sys.stderr.write \
          (
                "Usage:\n\n\t%s %s%s %s\n\n%s.\n"
            %
                (
                    sys.argv[0],
                    prefix,
                    cmd,
                    commands[cmd]["help_usage"],
                    commands[cmd]["help_descr"],
                )
          )
    #end if
    if command_candidates != None :
        if len(command_candidates) != 0 :
            sys.stderr.write \
              (
                    "\nValid %(sub)scommands%(matching)s are: %(commands)s.\n"
                %
                    {
                        "sub" : ("", "sub")[commands != recognized_commands],
                        "matching" :
                            ["", " matching \"%s\"" % command_match][command_match != None],
                        "commands" : ", ".join(sorted(command_candidates)),
                    }
              )
        else :
            sys.stderr.write("No commands matching \"%s\".\n" % command_match)
        #end if
    #end if
#end cmd_help

def cmd_dgntojson(args, opts) :
    infile = args[0]
    dunge = DungeonFile.load(infile)
    out = sys.stdout
    out.write("[\n")
    out2 = IndentedOutput(out)
    out3 = IndentedOutput(out2)
    out4 = IndentedOutput(out3)
    out2.start_list()
    for dungeon in dunge :
        out2.next_item(",\n")
        out2.write("{\n")
        out3.write("\"name\":%s,\n" % json.dumps(dungeon.name))
        out3.write("\"rooms\":[\n")
        out4.start_list()
        for l in range(0, Dungeon.NR_LEVELS) :
            for s in range(0, Dungeon.NR_ROOMS_SN) :
                for e in range(0, Dungeon.NR_ROOMS_EW) :
                    room = dungeon[l, s, e]
                    out4.next_item(",\n")
                    out4.write \
                      (
                            "{\"loc\":[%d,%d,%d],\"west_side\":%s,\"north_side\":%s"
                        %
                            (
                                l,
                                s,
                                e,
                                json.dumps(room.west_side.name),
                                json.dumps(room.north_side.name),
                            )
                      )
                    if room.special != SPC.NONE :
                        out4.write(",\"spc\":%s" % json.dumps(room.special.name))
                    #end if
                    out4.write("}")
                #end for
            #end for
        #end for
        out4.finish_list("\n")
        out4.write("],\n")
        out3.write("\"start\":")
        if dungeon.start != None :
            out3.write("[%d,%d,%d]" % dungeon.start)
        else :
            out3.write("null")
        #end if
        out3.write("\n")
        out2.write("}")
    #end for
    out2.finish_list("\n")
    out.write("]\n")
    out.flush()
#end cmd_dgntojson

def cmd_dgnfromjson(args, opts) :
    outfile = args[0]
    jdunge = json.load(sys.stdin)
    assert type(jdunge) == list, "expecting list of dungeons"
    dunge = DungeonFile()
    for jd in jdunge :
        assert type(jd) == dict, "expecting dict to define dungeon"
        assert "name" in jd and "rooms" in jd and "start" in jd, "dungeon dict must define name, rooms and start"
        d = Dungeon.new_empty(jd["name"])
        d.start = jd["start"]
        jrooms = jd["rooms"]
        assert len(jrooms) == Dungeon.NR_LEVELS * Dungeon.NR_ROOMS_SN * Dungeon.NR_ROOMS_EW, "expecting 8000 rooms"
        for l in range(0, Dungeon.NR_LEVELS) :
            for s in range(0, Dungeon.NR_ROOMS_SN) :
                for e in range(0, Dungeon.NR_ROOMS_EW) :
                    jroom = jrooms[l * Dungeon.NR_ROOMS_SN * Dungeon.NR_ROOMS_EW + s * Dungeon.NR_ROOMS_EW + e]
                    assert jroom["loc"] == [l, s, e], "room coords mismatch"
                    room = d[l, s, e]
                    room.west_side = ROOM_SIDE.__members__[jroom["west_side"]]
                    room.north_side = ROOM_SIDE.__members__[jroom["north_side"]]
                    if "spc" in jroom :
                        room.special = SPC.__members__[jroom["spc"]]
                    else :
                        room.special = SPC.NONE
                    #end if
                #end for
            #end for
        #end for
        dunge.append(d)
    #end for
    dunge.save(outfile)
#end cmd_dgnfromjson

def cmd_dgnlist(args, opts) :
    dgnfile = args[0]
    dungeons = DungeonFile.load(dgnfile)
    for i, dungeon in enumerate(dungeons) :
        sys.stdout.write("%3d %s\n" % (i + 1, dungeon.name))
    #end for
#end cmd_dgnlist

def cmd_dgnmap(args, opts) :

    class map_params :
        room_width = 20.0
        room_height = 20.0
        grid_thickness = 0.5
        wall_thickness = 4.0
        door_gap = 1 / 3
        map_padding = (40.0, 12.0, 12.0, 24.0) # top, right, bottom, left à la CSS
        title_y = -25.0
        title_size = 10.0
        special_size = 6.0
        row_coords_x = -15.0
        col_coords_y = -10.0

        bg_color = colorsys.hsv_to_rgb(0, 0, 1)
        text_color = colorsys.hsv_to_rgb(0, 0, 0)
        wall_color = colorsys.hsv_to_rgb(0, 0, 0)
        grid_color = colorsys.hsv_to_rgb(0.55, 0.4, 0.8)
        rubble_color = colorsys.hsv_to_rgb(0, 0, 0.7)

        scaling = 2.0
    #end map_params

#begin cmd_dgnmap
    dgnfile, dgnname, level, outfile = args
    level = int(level)
    dungeons = DungeonFile.load(dgnfile)
    dungeon = dungeons[dgnname]
    # option to specify pixel density?
    pix = cairo.ImageSurface \
      (
        cairo.FORMAT_RGB24, # format
        round((map_params.room_width * Dungeon.NR_ROOMS_EW + map_params.map_padding[1] + map_params.map_padding[3]) * map_params.scaling), # width
        round((map_params.room_height * Dungeon.NR_ROOMS_SN + map_params.map_padding[0] + map_params.map_padding[2]) * map_params.scaling) # height
      )
    g = cairo.Context(pix)
    g.scale(map_params.scaling, map_params.scaling)
    g.translate(map_params.map_padding[3], map_params.map_padding[0])
    g.set_source_rgb(*map_params.bg_color)
    g.paint()
    g.set_source_rgb(*map_params.text_color)
    g.select_font_face("sans-serif")
    g.set_font_size(map_params.title_size)
    g.move_to(map_params.room_width * Dungeon.NR_ROOMS_EW / 2, map_params.title_y)
    draw_centred_text(g, "%s — level %d" % (dgnname, level))
    g.set_source_rgb(*map_params.grid_color)
    for south in range(0, Dungeon.NR_ROOMS_SN) :
        g.move_to(map_params.row_coords_x, (south + 0.5) * map_params.room_height)
        draw_centred_text(g, "%d" % south)
    #end for
    for east in range(0, Dungeon.NR_ROOMS_EW) :
        g.move_to((east + 0.5) * map_params.room_width, map_params.col_coords_y)
        draw_centred_text(g, "%d" % east)
    #end for
    g.set_line_width(map_params.grid_thickness)
    g.new_path()
    for south in range(0, Dungeon.NR_ROOMS_SN + 1) :
        g.move_to(0, map_params.room_height * south)
        g.rel_line_to(map_params.room_width * Dungeon.NR_ROOMS_EW, 0)
    #end for
    for east in range(0, Dungeon.NR_ROOMS_EW + 1) :
        g.move_to(map_params.room_width * east, 0)
        g.rel_line_to(0, map_params.room_height * Dungeon.NR_ROOMS_SN)
    #end for
    g.stroke()
    g.set_source_rgb(*map_params.wall_color)
    g.set_line_width(map_params.wall_thickness)
    g.set_font_size(map_params.special_size)
    if dungeon.start != None and level == dungeon.start[0] :
        g.move_to((dungeon.start[2] + 0.5) * map_params.room_width, (dungeon.start[1] + 0.5) * map_params.room_height)
        draw_centred_text(g, "X")
    #end if
    for south in range(0, Dungeon.NR_ROOMS_SN) :
        for east in range(0, Dungeon.NR_ROOMS_EW) :
            room = dungeon[level, south, east]
            if room.west_side != ROOM_SIDE.OPEN :
                g.new_path()
                g.move_to(east * map_params.room_width, south * map_params.room_height)
                if room.west_side == ROOM_SIDE.WALL :
                    g.rel_line_to(0, map_params.room_height)
                elif room.west_side == ROOM_SIDE.DOOR :
                    g.rel_line_to(0, map_params.room_height * (1 - map_params.door_gap) / 2)
                    g.rel_move_to(0, map_params.room_height * map_params.door_gap)
                    g.rel_line_to(0, map_params.room_height * (1 - map_params.door_gap) / 2)
                elif room.west_side == ROOM_SIDE.RUBBLE :
                    g.set_source_rgb(*map_params.rubble_color)
                    g.rel_line_to(0, map_params.room_height)
                #end if
                g.stroke()
                g.set_source_rgb(*map_params.wall_color)
            #end if
            if room.north_side != ROOM_SIDE.OPEN :
                g.new_path()
                g.move_to(east * map_params.room_width, south * map_params.room_height)
                if room.north_side == ROOM_SIDE.WALL :
                    g.rel_line_to(map_params.room_width, 0)
                elif room.north_side == ROOM_SIDE.DOOR :
                    g.rel_line_to(map_params.room_width * (1 - map_params.door_gap) / 2, 0)
                    g.rel_move_to(map_params.room_width * map_params.door_gap, 0)
                    g.rel_line_to(map_params.room_width * (1 - map_params.door_gap) / 2, 0)
                elif room.north_side == ROOM_SIDE.RUBBLE :
                    g.set_source_rgb(*map_params.rubble_color)
                    g.rel_line_to(0, map_params.room_width)
                #end if
                g.stroke()
                g.set_source_rgb(*map_params.wall_color)
            #end if
            if south != 0 and east != 0 :
                if (
                        (room.get_side(DIR.W) != ROOM_SIDE.OPEN) != (room.neighbour(DIR.N).get_side(DIR.W) != ROOM_SIDE.OPEN)
                    and
                        (room.get_side(DIR.N) != ROOM_SIDE.OPEN) != (room.neighbour(DIR.W).get_side(DIR.N) != ROOM_SIDE.OPEN)
                ) :
                    # fill in notch in right-angle corner in wall
                    g.new_path()
                    g.move_to(east * map_params.room_width - map_params.wall_thickness / 2, south * map_params.room_height - map_params.wall_thickness / 2)
                    g.rel_line_to(map_params.wall_thickness, 0)
                    g.rel_line_to(0, map_params.wall_thickness)
                    g.rel_line_to(- map_params.wall_thickness, 0)
                    g.close_path()
                    g.fill()
                #end if
            #end if
            if room.special != SPC.NONE :
                g.move_to((east + 0.5) * map_params.room_width, (south + 0.5) * map_params.room_height)
                draw_centred_text(g, room.special.name)
            #end if
        #end for
        g.new_path()
        g.move_to(map_params.room_width * Dungeon.NR_ROOMS_EW, - map_params.wall_thickness / 2)
        g.rel_line_to(0, map_params.room_height * Dungeon.NR_ROOMS_SN + map_params.wall_thickness) # easternmost wall
        g.stroke()
    #end for
    g.new_path()
    g.move_to(- map_params.wall_thickness / 2, map_params.room_height * Dungeon.NR_ROOMS_SN)
    g.rel_line_to(map_params.room_width * Dungeon.NR_ROOMS_EW + map_params.wall_thickness, 0) # southernmost wall
    g.stroke()
    pix.flush()
    pix.write_to_png(outfile)
#end cmd_dgnmap

def cmd_dgnspecials(args, opts) :
    dgnfile = args[0]
    dgnname = args[1]
    dungeons = DungeonFile.load(dgnfile)
    try :
        dungeon = dungeons[dgnname]
    except KeyError :
        raise getopt.GetoptError("no such dungeon %s in file %s" % (repr(dgnname), dgnfile))
    #end try
    for spc in SPC :
        if spc != SPC.NONE :
            rooms = list(dungeon.find_special_rooms(spc))
            sys.stdout.write("%s: " % (spc.name))
            if len(rooms) != 0 :
                sys.stdout.write(", ".join("[%d, %d, %d]" % (room.l, room.s, room.e) for room in rooms))
            else :
                sys.stdout.write("(none)")
            #end if
            sys.stdout.write("\n")
        #end if
    #end for
#end cmd_dgnspecials

def cmd_chrtojson(args, opts) :
    infile = args[0]
    characters = CharacterFile.load(infile)
    out = sys.stdout
    out.write("[\n")
    out2 = IndentedOutput(out)
    out3 = IndentedOutput(out2)
    out4 = IndentedOutput(out3)
    out2.start_list()
    for character in characters :
        out2.next_item(",\n")
        out2.write("{\n")
        out3.write("\"name\":%s,\n" % json.dumps(character.name))
        out3.write("\"secret_name\":%s,\n" % json.dumps(character.secret_name))
        out3.write("\"attributes\":{\n")
        out4.start_list()
        for attrib in UC :
            out4.next_item(",\n")
            out4.write("\"%s\":%d" % (attrib.name, character.attributes[attrib]))
        #end for
        out4.finish_list("\n")
        out3.write("}\n")
        out2.write("}")
    #end for
    out2.finish_list("\n")
    out.write("]\n")
    out.flush()
#end cmd_chrtojson

def cmd_chrfromjson(args, opts) :
    outfile = args[0]
    jchars = json.load(sys.stdin)
    assert type(jchars) == list, "expecting list of characters"
    chars = CharacterFile()
    for jchar in jchars :
        assert type(jchar) == dict, "expecting dict to define character"
        assert "name" in jchar and "secret_name" in jchar and "attributes" in jchar, \
            "character dict must define name, secret_name and attributes"
        c = Character(jchar["name"], jchar["secret_name"])
        jattribs = jchar["attributes"]
        assert type(jattribs) == dict, "expecting dict to define attributes"
        attrs_seen = set()
        for k in jattribs :
            attrib = UC.__members__[k]
            c.attributes[attrib] = jattribs[k]
            attrs_seen.add(attrib)
        #end for
        missing = []
        for k in UC :
            if not k in attrs_seen :
                missing.append(k.name)
            #end if
        #end for
        if len(missing) != 0 :
            raise ValueError("missing character attribute(s): %s" % ",".join(missing))
        #end if
        chars.append(c)
    #end for
    chars.save(outfile)
#end cmd_chrfromjson

def cmd_chrlist(args, opts) :
    infile = args[0]
    characters = CharacterFile.load(infile)
    for i, character in enumerate(characters) :
        if character.attributes[UC.ALIVE] :
            sys.stdout.write("%3d %s\n" % (i + 1, character.name))
        #end if
    #end for
#end cmd_chrlist

help_cmd = "help"
recognized_commands = \
  {
# key is command name, value is dictionary with following fields:
#     args -- nr required positional args, or tuple of min and max nr required positional args
#     opts -- tuple of long option names. If a name ends in an equal sign, then it takes a value.
#     multivalued -- optional tuple of option keywords which can occur multiple times
#     required -- optional tuple of option keywords which must be present
#     subcmds -- alternative to above, a dictionary of subcommands
#     help_usage -- used to construct a usage string when giving help for the command.
#     help_descr -- explanatory text shown when giving help for the command.
#     action -- the function to invoke to actually perform the command.

    "help" :
      {
        "args" : (0, 1),
        "opts" : (),
        "action" : cmd_help,
        "help_usage" : "[cmd]",
        "help_descr" : "gives help about the specified command",
      },

    "dgn" :
      {
        "subcmds" :
          {
            "decode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_dgntojson,
                "help_usage" : "dgnfile",
                "help_descr" : "converts a dungeon file to JSON format to stdout",
              },

            "encode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_dgnfromjson,
                "help_usage" : "dgnfile",
                "help_descr" : "generates a dungeon file from JSON format from stdin",
              },

            "list" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_dgnlist,
                "help_usage" : "dgnfile",
                "help_descr": "lists the names of the dungeons in the specified dungeon file",
              },

            "map" :
              {
                "args" : 4,
                "opts" : (),
                "action" : cmd_dgnmap,
                "help_usage" : "dgnfile dgnname level outfile",
                "help_descr" :
                    "generates a map in PNG format of the specified level of the specified dungeon",
              },

            "specials" :
              {
                "args" : 2,
                "opts" : (),
                "action" : cmd_dgnspecials,
                "help_usage" : "dgnfile dgnname",
                "help_descr" : "lists special room contents for the specified dungeon in the specified file",
              },
          },
        "help_descr" : "invokes subcommands for managing dungeon level files",
      },

    "chr" :
      {
        "subcmds" :
          {
            "decode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrtojson,
                "help_usage" : "chrfile",
                "help_descr" : "converts a character file to JSON format to stdout",
              },

            "encode" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrfromjson,
                "help_usage" : "chrfile",
                "help_descr" : "generates a character file from JSON format from stdin",
              },

            "list" :
              {
                "args" : 1,
                "opts" : (),
                "action" : cmd_chrlist,
                "help_usage" : "chrfile",
                "help_descr" : "lists the names of the characters in the specified character file",
              },
          },
        "help_descr" : "invokes subcommands for managing character files",
      },
  }

def complete_recognized_commands() :
    # gives every subcommand a help entry.

    class subcmd_help :
        # for saving a subcommand context for passing to cmd_help.
        def __init__(self, prefix, subcmds) :
            self.prefix = prefix
            self.subcmds = subcmds
        #end __init__
        def __call__(self, args, opts) :
            cmd_help(args, opts, self.prefix, self.subcmds)
        #end __call__
    #end subcmd_help

#begin complete_recognized_commands
    for cmd in recognized_commands :
        cmd_entry = recognized_commands[cmd]
        if "subcmds" in cmd_entry :
            subhelp = dict(recognized_commands[help_cmd])
            subhelp["action"] = subcmd_help(cmd + " ", cmd_entry["subcmds"])
            subhelp["help_usage"] = "[subcmd]"
            subhelp["help_descr"] = "gives help about the specified subcommand"
            cmd_entry["subcmds"][help_cmd] = subhelp
            cmd_entry["help_usage"] = "subcmd"
        #end if
    #end for
#end complete_recognized_commands

complete_recognized_commands()
del complete_recognized_commands # your work is done

#+
# Mainline
#-

def mainline() :
    global cmd_prefix
    if len(sys.argv) < 2 :
        raise getopt.GetoptError("need at least one arg, the command to execute")
    #end if
    cmd = sys.argv[1]
    cmd_entry = recognized_commands.get(cmd)
    if cmd_entry == None :
        raise getopt.GetoptError("unrecognized command %s" % repr(cmd))
    #end if
    if "subcmds" in cmd_entry :
        if len(sys.argv) < 3 :
            raise getopt.GetoptError \
              (
                "%s command needs at least one more arg, the subcommand to execute" % cmd
              )
        #end if
        cmd_rest = sys.argv[3:]
        subcmd = sys.argv[2]
        cmd_entry = cmd_entry["subcmds"].get(subcmd)
        if cmd_entry == None :
            raise getopt.GetoptError("unrecognized %s subcommand %s" % (cmd, repr(subcmd)))
        #end if
        cmd_prefix = "%s %s" % (cmd, subcmd)
    else :
        cmd_rest = sys.argv[2:]
        subcmd = None
        cmd_prefix = cmd
    #end if
    opts_list, args = getopt.gnu_getopt(cmd_rest, "", cmd_entry["opts"])
    if type(cmd_entry["args"]) == tuple :
        if (
                len(cmd_entry["args"]) == 2
            and
                (
                    len(args) < cmd_entry["args"][0]
                or
                    len(args) > cmd_entry["args"][1]
                )
        ) :
            raise getopt.GetoptError \
              (
                "%s command needs %u..%u args" % ((cmd_prefix,) + cmd_entry["args"])
              )
        #end if
    else :
        if len(args) != cmd_entry["args"] :
            raise getopt.GetoptError \
              (
                "%s command needs exactly %u args" % (cmd_prefix, cmd_entry["args"])
              )
        #end if
    #end if
    opts = {}
    multi_opts = frozenset(cmd_entry.get("multivalued", ()))
    for keyword, value in opts_list :
        if keyword[:2] == "--" :
            keyword = keyword[2:]
            if keyword in multi_opts :
                values = opts.get(keyword, [])
                values.append(value)
                opts[keyword] = values
            else :
                opts[keyword] = value
            #end if
        #end if
    #end for
    required_opts = cmd_entry.get("required")
    if required_opts != None :
        missing = set(required_opts) - set(opts.keys())
        if len(missing) != 0 :
            raise getopt.GetoptError \
              (
                "%s command needs option(s) %s" % (cmd_prefix, ",".join(tuple(missing)))
              )
        #end if
    #end if
    cmd_entry["action"](args, opts) # can raise exceptions
#end mainline

mainline()
